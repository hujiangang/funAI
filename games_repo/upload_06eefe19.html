<!doctype html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>è®°å¿†é»‘å¸‚ â€” çµé­‚ç¢ç‰‡æ‹¼å›¾</title>
  <style>
    :root{
      --bg:#0f1226; --panel:#11121a; --accent:#ffb86b; --muted:#9aa3c7;
    }
    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071020 0%,var(--bg) 60%);color:#e6eef8}
    .wrap{max-width:980px;margin:28px auto;padding:20px}
    header{display:flex;align-items:center;gap:16px}
    .logo{width:64px;height:64px;border-radius:12px;background:linear-gradient(135deg,var(--accent),#ff7ab6);display:flex;align-items:center;justify-content:center;font-weight:700;color:#1b1720}
    h1{margin:0;font-size:20px}
    p.lead{margin:6px 0 0;color:var(--muted);font-size:13px}

    main{display:grid;grid-template-columns:320px 1fr;gap:18px;margin-top:18px}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:14px;border-radius:12px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}

    .left{position:relative}
    .stats{display:flex;flex-direction:column;gap:8px}
    .stat{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
    .meter{height:10px;background:rgba(255,255,255,0.05);border-radius:999px;overflow:hidden}
    .meter > i{display:block;height:100%;background:linear-gradient(90deg,#ffd28a,#ff7ab6);width:50%}

    .board{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:14px}
    .tile{aspect-ratio:1/1;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.02));border-radius:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative;user-select:none;transition:transform .18s ease, box-shadow .12s}
    .tile:active{transform:translateY(2px)}
    .tile.revealed{background:linear-gradient(180deg,#1b1026,#2a1735);box-shadow:inset 0 0 40px rgba(0,0,0,0.5)}
    .tile .emoji{font-size:28px}
    .tile .label{position:absolute;bottom:8px;left:8px;right:8px;font-size:11px;color:var(--muted);text-align:center}

    .right{display:flex;flex-direction:column;gap:12px}
    .log{height:200px;overflow:auto;padding:8px;border-radius:8px;background:rgba(0,0,0,0.12);font-size:13px}
    .controls{display:flex;gap:8px}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:inherit;cursor:pointer}
    button:active{transform:translateY(1px)}

    footer{margin-top:18px;color:var(--muted);font-size:13px}

    /* small */
    @media(max-width:880px){main{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo">MM</div>
      <div>
        <h1>è®°å¿†é»‘å¸‚ï¼šçµé­‚ç¢ç‰‡æ‹¼å›¾</h1>
        <p class="lead">ä¸€ä¸ªèåˆè®°å¿†ä¸èµŒè¿æ°”çš„åˆ›æ„åŒ¹é…æ¸¸æˆ â€”â€” æ”¶é›†ä½ é—å¤±çš„ä¸‰æ®µè®°å¿†ï¼ŒåŒæ—¶æé˜²è™šå‡çš„ç¢ç‰‡ä¸æ±¡æŸ“äº‹ä»¶ã€‚</p>
      </div>
    </header>

    <main>
      <section class="panel left">
        <div class="stats">
          <div class="stat"><div>è®°å¿†æŒ‡æ•°</div><div class="meter" title="è®°å¿†æŒ‡æ•°"><i id="memoryMeter"></i></div></div>
          <div class="stat"><div>å·²æ”¶é›†ç¢ç‰‡</div><div id="collected">0 / 3</div></div>
          <div class="stat"><div>çº¿ç´¢æ§½</div><div id="clues">0 / 5</div></div>
        </div>

        <div style="margin-top:12px;display:flex;gap:8px;align-items:center;">
          <button id="shuffleBtn">é‡æ–°æ´—ç‰Œï¼ˆæ–°å…³å¡ï¼‰</button>
          <button id="hintBtn">èŠ±è´¹10è®°å¿†æŒ‡æ•°è·å¾—çº¿ç´¢</button>
        </div>

        <div class="board panel" id="board" style="margin-top:14px"></div>

        <div style="margin-top:12px;font-size:13px;color:var(--muted)">ç©æ³•æç¤ºï¼š<br>ç‚¹å‡»å¡ç‰Œç¿»å¼€ç¢ç‰‡ã€‚é…å¯¹ä¸‰å¼ å±äºåŒä¸€è®°å¿†ä¸»é¢˜çš„ç¢ç‰‡å³å¯é‡å»ºé‚£æ®µè®°å¿†ã€‚æŸäº›å¡ç‰Œä¼šæ˜¯â€œæ±¡æŸ“â€æˆ–â€œå½±å­å•†äººâ€çš„é™·é˜±ï¼Œä¼šæ‰£å‡è®°å¿†æŒ‡æ•°æˆ–æ±¡æŸ“çº¿ç´¢ã€‚</div>
      </section>

      <aside class="panel right">
        <div>
          <strong>ç›®æ ‡</strong>
          <div style="color:var(--muted);margin-top:6px">æ”¶é›†å¹¶é‡å»º <strong>3 æ®µè®°å¿†</strong>ã€‚è®°å¿†æŒ‡æ•°é™ä¸º 0 å³å¤±è´¥ã€‚</div>
        </div>

        <div>
          <strong>æ—¥å¿—</strong>
          <div class="log" id="log"></div>
        </div>

        <div>
          <strong>èƒŒåŒ… / çº¿ç´¢</strong>
          <div style="margin-top:8px;color:var(--muted)"><span id="backpack">ç©º</span></div>
        </div>

        <div style="margin-top:8px" class="controls">
          <button id="useClueBtn">ä½¿ç”¨çº¿ç´¢ï¼ˆæ¶ˆè€— 1 çº¿ç´¢ï¼‰</button>
          <button id="tradeBtn">ä¸å½±å­å•†äººäº¤æ˜“ï¼ˆæœ‰é£é™©ï¼‰</button>
        </div>

      </aside>
    </main>

    <footer class="panel">
      <div>åˆ›æ„å°æ¸¸æˆ Â· å•æ–‡ä»¶ HTMLã€‚ä½ å¯ä»¥æŠŠæ­¤æ–‡ä»¶ä¿å­˜ä¸º <code>memory-market.html</code> å¹¶åœ¨æµè§ˆå™¨æ‰“å¼€æ¥ç©ã€‚</div>
    </footer>
  </div>

  <script>
    // Game data
    const MEMORIES = [
      {id:'lostToy', name:'æ›¾ç»å¤±å»çš„ä¸œè¥¿', emoji:'ğŸª€'},
      {id:'beloved', name:'æœ€çæƒœçš„äºº', emoji:'ğŸ’–'},
      {id:'secret', name:'æ— æ³•è¯´å‡ºå£çš„ç§˜å¯†', emoji:'ğŸ”'},
    ];

    const TILES_PER_ROW = 4; // 4x3 grid
    const ROWS = 3;
    const TOTAL_TILES = TILES_PER_ROW * ROWS;

    let state = {
      memoryIndex: 50,
      collected: 0,
      clues: 0,
      backpack: [],
      revealed: [],
      board: [],
      locked: false,
      builtMemories: new Set()
    }

    const boardEl = document.getElementById('board');
    const meterEl = document.getElementById('memoryMeter');
    const collectedEl = document.getElementById('collected');
    const cluesEl = document.getElementById('clues');
    const logEl = document.getElementById('log');
    const backpackEl = document.getElementById('backpack');

    function log(text){
      const line = document.createElement('div');
      line.textContent = `${new Date().toLocaleTimeString()} â€¢ ${text}`;
      logEl.prepend(line);
    }

    function randInt(n){return Math.floor(Math.random()*n)}

    function clamp(v,min,max){return Math.max(min,Math.min(max,v))}

    function updateUI(){
      meterEl.style.width = clamp(state.memoryIndex,0,100) + '%';
      collectedEl.textContent = state.collected + ' / ' + MEMORIES.length;
      cluesEl.textContent = state.clues + ' / 5';
      backpackEl.textContent = state.backpack.length ? state.backpack.map(t=>t.emoji).join(' ') : 'ç©º';

      if(state.memoryIndex<=0){
        alert('è®°å¿†æŒ‡æ•°é™ä¸º 0ï¼Œä½ å¤±å»äº†è‡ªæˆ‘â€¦ æ¸¸æˆç»“æŸã€‚');
        init();
      }

      if(state.collected >= MEMORIES.length){
        alert('æ­å–œï¼ä½ é‡å»ºäº†å…¨éƒ¨è®°å¿†ã€‚å›å¿†æ¶Œæ¥ï¼Œä½ ç»ˆäºæ‰¾å›äº†è‡ªå·±ã€‚');
        init();
      }
    }

    function init(){
      state.memoryIndex = 50;
      state.collected = 0;
      state.clues = 1; // give one clue to start
      state.backpack = [];
      state.revealed = [];
      state.locked = false;
      state.builtMemories = new Set();
      prepareBoard();
      renderBoard();
      log('æ¸¸æˆå·²é‡ç½®ã€‚ä½ å¸¦ç€ä¸€ä¸ææƒ§èµ°è¿›è®°å¿†é»‘å¸‚ã€‚');
      updateUI();
    }

    function prepareBoard(){
      // We'll create pairs/triples: for each memory, 3 fragments (total 9), add 3 traps and filler ghosts
      const fragments = [];
      // three fragments per real memory
      MEMORIES.forEach(m => {
        for(let i=0;i<3;i++) fragments.push({type:'fragment', memId:m.id, name:m.name, emoji:m.emoji});
      });
      // add traps: pollution, shadow
      const traps = [
        {type:'pollution', name:'æ±¡æŸ“ç¢ç‰‡', emoji:'ğŸ¦ '},
        {type:'shadow', name:'å½±å­ç¢ç‰‡', emoji:'ğŸ•³ï¸'},
        {type:'glitch', name:'è®°å¿†é”™ä½', emoji:'âš¡'}
      ];
      // fill remaining tiles with traps/random
      while(fragments.length + traps.length < TOTAL_TILES) traps.push({type:'ghost', name:'ç©ºç™½ç¢ç‰‡', emoji:'ğŸ’­'});

      const pool = fragments.concat(traps).slice(0, TOTAL_TILES);

      // shuffle
      for(let i=pool.length-1;i>0;i--){
        const j = randInt(i+1);
        [pool[i],pool[j]] = [pool[j],pool[i]];
      }

      state.board = pool.map((item,idx)=>({...item, id:idx, revealed:false, matched:false}));
    }

    function renderBoard(){
      boardEl.innerHTML = '';
      state.board.forEach(tile => {
        const el = document.createElement('div');
        el.className = 'tile' + (tile.revealed ? ' revealed' : '');
        el.dataset.id = tile.id;
        if(tile.revealed){
          el.innerHTML = `<div class="emoji">${tile.emoji}</div><div class="label">${tile.name}</div>`;
        } else {
          el.innerHTML = `<div class="emoji">â“</div>`;
        }
        if(tile.matched){
          el.style.outline = '2px solid rgba(255,255,255,0.06)';
          el.style.opacity = 0.7;
          el.style.pointerEvents = 'none';
        }
        el.addEventListener('click', ()=>onTileClick(tile.id));
        boardEl.appendChild(el);
      });
    }

    function onTileClick(id){
      if(state.locked) return;
      const tile = state.board.find(t=>t.id===id);
      if(!tile || tile.revealed || tile.matched) return;
      tile.revealed = true;
      state.revealed.push(tile);
      renderBoard();
      log(`ç¿»å¼€ï¼š${tile.name}`);

      // special tiles
      if(tile.type === 'pollution'){
        state.memoryIndex -= 12; state.clues = Math.max(0,state.clues-1);
        log('æ±¡æŸ“ç¢ç‰‡ï¼ä½ çš„çº¿ç´¢è¢«æ±¡æŸ“ï¼Œè®°å¿†æŒ‡æ•°ä¸‹é™ã€‚');
        checkAfterReveal();
        return;
      }
      if(tile.type === 'shadow'){
        // shadow steals a random fragment from backpack if any
        if(state.backpack.length){
          const stolen = state.backpack.pop();
          state.memoryIndex -= 8; log(`å½±å­å•†äººçªƒå–äº†ä½ çš„ç¢ç‰‡ ${stolen.name}ã€‚`);
        } else { state.memoryIndex -= 6; log('å½±å­å•†äººç¢°äº†ç©ºã€‚ä½ çš„è®°å¿†è¢«æ’•æ‰¯æ„Ÿåˆ°è™šå¼±ã€‚'); }
        checkAfterReveal();
        return;
      }
      if(tile.type === 'glitch'){
        // shuffle a subset
        shuffleBoardSegment(); state.memoryIndex -= 5; log('è®°å¿†é”™ä½ï¼šç¢ç‰‡ä½ç½®å‘ç”Ÿäº†å¾®å°ç§»åŠ¨ã€‚');
        checkAfterReveal();
        return;
      }

      // normal fragment logic: try to collect 3 of same memId
      const revealedFragments = state.revealed.filter(r=>r.type==='fragment');
      // if we have 3 fragments of same memId among revealed or backpack, build memory
      const counts = {};
      revealedFragments.forEach(f=>counts[f.memId] = (counts[f.memId]||0)+1);

      // also include backpack
      state.backpack.filter(b=>b.type==='fragment').forEach(f=>counts[f.memId] = (counts[f.memId]||0)+1);

      for(const memId in counts){
        if(counts[memId] >= 3 && !state.builtMemories.has(memId)){
          // build memory: consume three fragments from revealed+backpack
          consumeFragmentsFor(memId);
          return;
        }
      }

      // if too many revealed (>=3) without building, move one to backpack or penalize
      if(state.revealed.length >= 3){
        // move first revealed fragment to backpack if space
        const frag = state.revealed.find(r=>r.type==='fragment');
        if(frag){
          if(state.backpack.length < 3){
            state.backpack.push(frag);
            state.board.find(b=>b.id===frag.id).matched = true; // remove from board visually
            log(`æŠŠç¢ç‰‡ ${frag.name} æ”¾å…¥èƒŒåŒ…ã€‚`);
          } else {
            state.memoryIndex -= 6; log('èƒŒåŒ…å·²æ»¡ï¼Œè®°å¿†æº¢å‡ºï¼Œä½ æ„Ÿè§‰å¤´ç—›ã€‚');
            // flip back earliest revealed
            const r = state.revealed.shift();
            r.revealed = false;
          }
        }
        state.revealed = state.revealed.filter(r=>r.type!=='fragment');
      }

      checkAfterReveal();
    }

    function checkAfterReveal(){
      // small chance of random event
      if(Math.random() < 0.08){
        state.memoryIndex -= 4; log('çªå‘äº‹ä»¶ï¼šé»‘å¸‚å·¡æŸ¥ï¼Œæƒ¶æè®©ä½ å¤±å»ä¸€ç‚¹è®°å¿†ã€‚');
      }
      // flip back unrevealed non-matched fragments after short delay
      state.locked = true;
      setTimeout(()=>{
        state.board.forEach(t=>{ if(!t.matched) t.revealed = false; });
        state.revealed = [];
        renderBoard();
        state.locked = false;
        updateUI();
      }, 700);
    }

    function consumeFragmentsFor(memId){
      // remove two more fragments from revealed/backpack to make total 3
      let need = 3;
      const used = [];
      // use revealed first
      for(let i=state.revealed.length-1;i>=0 && need>0;i--){
        const r = state.revealed[i];
        if(r.type==='fragment' && r.memId===memId){ used.push(r); state.revealed.splice(i,1); need--; }
      }
      // then backpack
      for(let i=state.backpack.length-1;i>=0 && need>0;i--){
        const b = state.backpack[i];
        if(b.type==='fragment' && b.memId===memId){ used.push(b); state.backpack.splice(i,1); need--; }
      }
      // finally board revealed
      if(need>0){
        for(let i=0;i<state.board.length && need>0;i++){
          const b = state.board[i];
          if(b.type==='fragment' && b.memId===memId && b.revealed){ used.push(b); b.matched=true; need--; }
        }
      }

      state.builtMemories.add(memId);
      state.collected++;
      state.memoryIndex = Math.min(100, state.memoryIndex + 18);
      log(`é‡å»ºè®°å¿†ï¼š${MEMORIES.find(m=>m.id===memId).name}ã€‚ä½ å›æƒ³èµ·ä¸€æ®µé‡è¦çš„è®°å¿†ã€‚`);

      // mark matched fragments on board
      state.board.forEach(b=>{ if(b.type==='fragment' && b.memId===memId) b.matched = true; });

      // give a clue occasionally
      if(Math.random() < 0.6) { state.clues = Math.min(5, state.clues+1); log('ä½ ä»é‡å»ºçš„è®°å¿†é‡Œè·å¾—äº†ä¸€æ¡çº¿ç´¢ã€‚'); }

      updateUI();
      // stall a bit and then continue
    }

    function shuffleBoardSegment(){
      // shuffle half the board
      const start = Math.floor(Math.random() * (TOTAL_TILES/2));
      const len = Math.floor(Math.random() * (TOTAL_TILES/2)) + 2;
      const segment = state.board.splice(start,len);
      for(let i=segment.length-1;i>0;i--){ const j=randInt(i+1); [segment[i],segment[j]]=[segment[j],segment[i]]; }
      state.board.splice(start,0,...segment);
      renderBoard();
    }

    // controls
    document.getElementById('shuffleBtn').addEventListener('click', ()=>{ init(); log('ä½ åœ¨é»‘å¸‚é‡Œæ¢äº†ä¸ªæ‘Šä½ï¼Œæ–°çš„ç« ç¨‹ã€‚'); });
    document.getElementById('hintBtn').addEventListener('click', ()=>{
      if(state.memoryIndex < 10){ alert('è®°å¿†æŒ‡æ•°ä¸è¶³ï¼Œæ— æ³•æ¢å–çº¿ç´¢ã€‚'); return; }
      state.memoryIndex -= 10; state.clues = Math.min(5, state.clues+1); log('ä½ ä»˜å‡ºè®°å¿†æ¢æ¥ä¸€æ¡çº¿ç´¢ã€‚'); updateUI();
    });
    document.getElementById('useClueBtn').addEventListener('click', ()=>{
      if(state.clues <= 0){ alert('æ²¡æœ‰çº¿ç´¢å¯ç”¨ã€‚'); return; }
      // reveal a random tile's name (not its position) as a hint (semantic clue)
      state.clues--; const available = state.board.filter(b=>!b.matched);
      if(available.length===0) { log('æ²¡æœ‰æ›´å¤šç¢ç‰‡ã€‚'); return; }
      const a = available[randInt(available.length)];
      log(`çº¿ç´¢ï¼šä½ æ„Ÿåˆ°ä¸€é˜µå›å¿†çš„æ°”å‘³ â€”â€” ${a.name}ã€‚`);
      updateUI();
    });
    document.getElementById('tradeBtn').addEventListener('click', ()=>{
      // gamble: pay 8 memoryIndex for chance of fragment
      if(state.memoryIndex < 8){ alert('è®°å¿†æŒ‡æ•°ä¸è¶³ï¼Œæ— æ³•äº¤æ˜“ã€‚'); return; }
      state.memoryIndex -= 8;
      const r = Math.random();
      if(r < 0.5){
        // give random fragment
        const availableFragments = state.board.filter(b=>b.type==='fragment' && !b.matched);
        if(availableFragments.length===0){ log('å½±å­å•†äººæ— è´§ï¼Œåªç•™ä¸‹ä¸€é˜µå¯’æ„ã€‚'); updateUI(); return; }
        const pick = availableFragments[randInt(availableFragments.length)];
        pick.matched = true; state.backpack.push(pick); log('å½±å­å•†äººç»™ä½ ä¸€å—ç¢ç‰‡ï¼ˆæœ‰ç‚¹é»¯æ·¡ï¼‰ã€‚');
      } else {
        // bad
        state.memoryIndex -= 6; state.clues = Math.max(0,state.clues-1); log('å½±å­å•†äººæ¬ºéª—ä½ ï¼Œç»™äº†ä½ ä¸€å—æ±¡æŸ“ç¢ç‰‡ã€‚');
      }
      updateUI(); renderBoard();
    });

    // start
    init();
  </script>
</body>
</html>
