<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ç®€æ˜“ç‰ˆç³–è±†äºº (Mini Fall Guys)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            font-size: 24px;
            font-weight: bold;
        }
        #instructions {
            font-size: 16px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>ğŸ ç›®æ ‡ï¼šå†²å‘ç»ˆç‚¹ï¼</div>
        <div id="instructions">WASD æˆ– æ–¹å‘é”®ç§»åŠ¨ | ç©ºæ ¼é”®è·³è·ƒ</div>
    </div>

    <!-- å¼•å…¥ Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- æ¸¸æˆé…ç½® ---
        const COLORS = {
            sky: 0x87CEEB,
            ground: 0xFFD700, // é‡‘é»„è‰²åœ°é¢
            player: 0xFF69B4, // ç³–è±†ç²‰
            obstacle: 0x4169E1, // éšœç¢è“
            finish: 0x32CD32  // ç»ˆç‚¹ç»¿
        };

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.sky);
        scene.fog = new THREE.Fog(COLORS.sky, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- ç¯å…‰ ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(-10, 20, 0);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        scene.add(dirLight);

        // --- ç©å®¶ (ç³–è±†) ---
        const playerGeometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
        const playerMaterial = new THREE.MeshStandardMaterial({ color: COLORS.player });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.castShadow = true;
        player.position.y = 5; // å‡ºç”Ÿé«˜åº¦
        player.position.x = 0;
        player.position.z = 0;
        scene.add(player);

        // --- åœ°å›¾ç”Ÿæˆ ---
        const obstacles = [];
        const levelLength = 100;

        // 1. åœ°é¢
        const groundGeo = new THREE.BoxGeometry(10, 1, levelLength + 10);
        const groundMat = new THREE.MeshStandardMaterial({ color: COLORS.ground });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.position.z = levelLength / 2 - 5;
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        // 2. ç»ˆç‚¹çº¿
        const finishGeo = new THREE.BoxGeometry(10, 0.1, 5);
        const finishMat = new THREE.MeshBasicMaterial({ color: COLORS.finish });
        const finishLine = new THREE.Mesh(finishGeo, finishMat);
        finishLine.position.set(0, 0.01, levelLength);
        scene.add(finishLine);

        // 3. éšœç¢ç‰©ç”Ÿæˆå‡½æ•°
        function createMovingBlock(z, speed, offset) {
            const geo = new THREE.BoxGeometry(3, 2, 2);
            const mat = new THREE.MeshStandardMaterial({ color: COLORS.obstacle });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(0, 1, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // è‡ªå®šä¹‰å±æ€§ç”¨äºåŠ¨ç”»
            mesh.userData = { 
                type: 'moving', 
                speed: speed, 
                offset: offset,
                baseX: 0 
            };
            
            scene.add(mesh);
            obstacles.push(mesh);
        }

        function createRotatingHammer(z, speed) {
            const group = new THREE.Group();
            group.position.set(0, 1.5, z);

            // æ†å­
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.rotation.z = Math.PI / 2;
            pole.castShadow = true;
            group.add(pole);

            // é”¤å¤´
            const headGeo = new THREE.BoxGeometry(1, 2, 1);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const head1 = new THREE.Mesh(headGeo, headMat);
            head1.position.x = 3.5;
            group.add(head1);
            
            const head2 = new THREE.Mesh(headGeo, headMat);
            head2.position.x = -3.5;
            group.add(head2);

            group.userData = { type: 'rotating', speed: speed };
            scene.add(group);
            obstacles.push(group);
        }

        // --- å…³å¡è®¾è®¡ ---
        // ç®€å•çš„å…³å¡å¸ƒå±€
        for(let z = 15; z < levelLength - 5; z += 15) {
            if (z % 30 === 0) {
                createRotatingHammer(z, 0.05);
            } else {
                createMovingBlock(z, 0.08, Math.random() * Math.PI);
            }
        }

        // --- ç‰©ç†å˜é‡ ---
        let velocity = new THREE.Vector3();
        let onGround = false;
        const speed = 0.15;
        const jumpForce = 0.4;
        const gravity = 0.015;

        // --- è¾“å…¥æ§åˆ¶ ---
        const keys = { w: false, a: false, s: false, d: false, space: false };

        window.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
                case ' ': keys.space = true; break;
                case 'arrowup': keys.w = true; break;
                case 'arrowdown': keys.s = true; break;
                case 'arrowleft': keys.a = true; break;
                case 'arrowright': keys.d = true; break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
                case ' ': keys.space = false; break;
                case 'arrowup': keys.w = false; break;
                case 'arrowdown': keys.s = false; break;
                case 'arrowleft': keys.a = false; break;
                case 'arrowright': keys.d = false; break;
            }
        });

        // --- ç¢°æ’æ£€æµ‹ (ç®€æ˜“ AABB) ---
        function checkCollision(player, obstacle) {
            const pBox = new THREE.Box3().setFromObject(player);
            const oBox = new THREE.Box3().setFromObject(obstacle);
            return pBox.intersectsBox(oBox);
        }

        // --- æ¸¸æˆå¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. ç©å®¶ç§»åŠ¨é€»è¾‘
            if (keys.w) player.position.z += speed;
            if (keys.s) player.position.z -= speed; // å…è®¸åé€€ï¼Œä½†åœ¨ç³–è±†äººä¸­ä¸»è¦æ˜¯å‰è¿›
            if (keys.a) player.position.x += speed;
            if (keys.d) player.position.x -= speed;

            // è·³è·ƒä¸é‡åŠ›
            if (keys.space && onGround) {
                velocity.y = jumpForce;
                onGround = false;
            }

            player.position.y += velocity.y;

            // åœ°é¢æ£€æµ‹
            if (player.position.y <= 1) { // èƒ¶å›Šé«˜åº¦çš„ä¸€åŠ
                player.position.y = 1;
                velocity.y = 0;
                onGround = true;
            } else {
                velocity.y -= gravity;
            }

            // æ‰è½æ£€æµ‹ (æ‰å‡ºå¹³å°)
            if (player.position.y < -5 || Math.abs(player.position.x) > 6) {
                resetGame();
            }

            // 2. éšœç¢ç‰©åŠ¨ç”»
            const time = Date.now() * 0.001;
            obstacles.forEach(obj => {
                if (obj.userData.type === 'moving') {
                    // å·¦å³ç§»åŠ¨
                    obj.position.x = Math.sin(time * 2 + obj.userData.offset) * 3.5;
                    
                    // ç¢°æ’æ£€æµ‹
                    if (checkCollision(player, obj)) {
                        // ç®€å•çš„å‡»é£æ•ˆæœ
                        velocity.y = 0.3;
                        player.position.z -= 1; 
                    }
                } else if (obj.userData.type === 'rotating') {
                    // æ—‹è½¬
                    obj.rotation.y += obj.userData.speed;
                    
                    // æ—‹è½¬ç‰©ä½“çš„ç¢°æ’ç¨å¾®å¤æ‚ï¼Œè¿™é‡Œåšç®€å•çš„è·ç¦»æ£€æµ‹ç®€åŒ–
                    if (player.position.distanceTo(obj.position) < 3) {
                        // å¦‚æœåœ¨èŒƒå›´å†…ï¼Œä¸”é«˜åº¦æ¥è¿‘
                        if (player.position.y < 3) {
                             // ç®€å•çš„å‡»é£
                             let pushDir = new THREE.Vector3().subVectors(player.position, obj.position).normalize();
                             player.position.x += pushDir.x * 0.5;
                             player.position.z += pushDir.z * 0.5;
                        }
                    }
                }
            });

            // 3. ç›¸æœºè·Ÿéš
            camera.position.x = player.position.x * 0.3; // ç¨å¾®å¹³æ»‘çš„Xè½´è·Ÿéš
            camera.position.y = player.position.y + 6;
            camera.position.z = player.position.z - 10; // ç›¸æœºåœ¨èƒŒå
            camera.lookAt(player.position);

            // 4. èƒœåˆ©æ£€æµ‹
            if (player.position.z >= levelLength) {
                alert("ğŸ‰ æ­å–œï¼ä½ èµ¢äº†ï¼");
                resetGame();
            }

            renderer.render(scene, camera);
        }

        function resetGame() {
            player.position.set(0, 5, 0);
            velocity.set(0, 0, 0);
        }

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>